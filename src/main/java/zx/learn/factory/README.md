# 工厂模式

## 简单工厂模式
### 定义：
　　定义一个工厂类，根据传入的参数不同返回不同的实例，被创建的实例具有共同的父类或接口。

### 适用场景：
其实由定义也大概能推测出其使用场景，首先由于只有一个工厂类，所以工厂类中创建的对象不能太多，否则工厂类的业务逻辑就太复杂了，其次由于工厂类封装了对象的创建过程，所以客户端应该不关心对象的创建。总结一下适用场景：
1. 需要创建的对象较少。
2. 客户端不关心对象的创建过程。


## 工厂方法模式
　　工厂方法模式是简单工厂的仅一步深化， 在工厂方法模式中，我们不再提供一个统一的工厂类来创建所有的对象，而是针对不同的对象提供不同的工厂。也就是说每个对象都有一个与之对应的工厂。

### 定义：
　　定义一个用于创建对象的接口，让子类决定将哪一个类实例化。工厂方法模式让一个类的实例化延迟到其子类。

　　这次我们先用实例详细解释一下这个定义，最后在总结它的使用场景。
### 适用场景：

1. 客户端不需要知道它所创建的对象的类。例子中我们不知道每个图片加载器具体叫什么名，只知道创建它的工厂名就完成了床架过程。
2. 客户端可以通过子类来指定创建对应的对象。


## 抽象工厂模式
　　这个模式最不好理解，而且在实际应用中局限性也蛮大的，因为这个模式并不符合开闭原则。实际开发还需要做好权衡。
　　抽象工厂模式是工厂方法的仅一步深化，在这个模式中的工厂类不单单可以创建一个对象，而是可以创建一组对象。这是和工厂方法最大的不同点。

### 定义：
　　提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。（ 在抽象工厂模式中，每一个具体工厂都提供了多个工厂方法用于产生多种不同类型的对象）

抽象工厂和工厂方法一样可以划分为4大部分：

* AbstractFactory（抽象工厂）声明了一组用于创建对象的方法，注意是一组。
* ConcreteFactory（具体工厂）：它实现了在抽象工厂中声明的创建对象的方法，生成一组具体对象。
* AbstractProduct（抽象产品）：它为每种对象声明接口，在其中声明了对象所具有的业务方法。
* ConcreteProduct（具体产品）：它定义具体工厂生产的具体对象。

### 适用场景：
1. 和工厂方法一样客户端不需要知道它所创建的对象的类。
2. 需要一组对象共同完成某种功能时。并且可能存在多组对象完成不同功能的情况。
3. 系统结构稳定，不会频繁的增加对象。（因为一旦增加就需要修改原有代码，不符合开闭原则）


> https://juejin.im/entry/58f5e080b123db2fa2b3c4c6

